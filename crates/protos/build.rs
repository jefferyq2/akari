// SPDX-License-Identifier: Apache-2.0
// Copyright (C) 2024 Akira Moroo
// Copyright The containerd Authors.

use std::{
    env,
    fs::{self, File},
    io::{BufRead, BufReader},
    path::PathBuf,
};

use ttrpc_codegen::{Codegen, Customize, ProtobufCustomize};

fn genmodule(name: &str, inputs: &[&str], async_all: bool) {
    let mut out_path = PathBuf::from(env::var("OUT_DIR").unwrap());
    out_path.push(name);

    fs::create_dir_all(&out_path).unwrap();

    Codegen::new()
        .inputs(inputs)
        .include("vendor/")
        .rust_protobuf()
        .rust_protobuf_customize(
            ProtobufCustomize::default()
                .gen_mod_rs(true)
                .generate_accessors(true),
        )
        .customize(Customize {
            async_all,
            ..Default::default()
        })
        .out_dir(&out_path)
        .run()
        .expect("Failed to generate ptotos");

    // Find all *.rs files generated by TTRPC codegen
    let files = fs::read_dir(&out_path)
        .unwrap()
        .filter_map(|entry| {
            let entry = entry.unwrap();
            if !entry.file_type().unwrap().is_file() {
                None
            } else {
                Some(entry.path())
            }
        })
        .collect::<Vec<_>>();

    // `include!` doesn't handle files with attributes:
    // - https://github.com/rust-lang/rust/issues/18810
    // - https://github.com/rust-lang/rfcs/issues/752
    // Remove all lines that start with:
    // - #![allow(unknown_lints)]
    // - #![cfg_attr(rustfmt, rustfmt::skip)]
    //
    for path in files {
        let file = File::open(&path).unwrap();

        let joined = BufReader::new(file)
            .lines()
            .filter_map(|line| {
                let line = line.unwrap();
                if line.starts_with("#!") || line.starts_with("//!") {
                    None
                } else {
                    Some(line)
                }
            })
            .collect::<Vec<_>>()
            .join("\r\n");

        fs::write(&path, joined).unwrap();
    }
}

fn main() {
    genmodule("types", &["vendor/google/protobuf/empty.proto"], false);

    genmodule("vm", &["vendor/retrage/akari/vm.proto"], false);

    #[cfg(feature = "async")]
    {
        genmodule("vm_async", &["vendor/retrage/akari/vm.proto"], true);
    }
}
